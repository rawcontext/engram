name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy_all:
        description: 'Force deploy all services'
        required: false
        default: 'false'
        type: boolean
      force_infra:
        description: 'Force infrastructure apply'
        required: false
        default: 'false'
        type: boolean

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  HETZNER_SERVER_IP: ${{ secrets.HETZNER_SERVER_IP }}

jobs:
  # Wait for CI to pass
  ci:
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  # Detect which components changed
  changes:
    runs-on: ubuntu-latest
    needs: ci
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      api: ${{ steps.filter.outputs.api }}
      search: ${{ steps.filter.outputs.search }}
      tuner: ${{ steps.filter.outputs.tuner }}
      observatory: ${{ steps.filter.outputs.observatory }}
      ingestion: ${{ steps.filter.outputs.ingestion }}
      memory: ${{ steps.filter.outputs.memory }}
      control: ${{ steps.filter.outputs.control }}
      docker_compose: ${{ steps.filter.outputs.docker_compose }}
      any_service: ${{ steps.any.outputs.result }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
              - 'packages/infra/**'
            api:
              - 'apps/api/**'
              - 'packages/common/**'
              - 'packages/logger/**'
              - 'packages/events/**'
              - 'packages/storage/**'
              - 'packages/graph/**'
            search:
              - 'apps/search/**'
            tuner:
              - 'apps/tuner/**'
            observatory:
              - 'apps/observatory/**'
            ingestion:
              - 'apps/ingestion/**'
              - 'packages/common/**'
              - 'packages/logger/**'
              - 'packages/events/**'
              - 'packages/storage/**'
              - 'packages/parser/**'
            memory:
              - 'apps/memory/**'
              - 'packages/common/**'
              - 'packages/logger/**'
              - 'packages/events/**'
              - 'packages/storage/**'
              - 'packages/graph/**'
            control:
              - 'apps/control/**'
              - 'packages/common/**'
              - 'packages/logger/**'
              - 'packages/events/**'
              - 'packages/storage/**'
              - 'packages/graph/**'
              - 'packages/vfs/**'
              - 'packages/temporal/**'
            docker_compose:
              - 'docker-compose.prod.yml'

      - name: Check if any service changed
        id: any
        run: |
          if [[ "${{ steps.filter.outputs.api }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.search }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.tuner }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.observatory }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.ingestion }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.memory }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.control }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.docker_compose }}" == "true" ]] || \
             [[ "${{ inputs.force_deploy_all }}" == "true" ]]; then
            echo "result=true" >> $GITHUB_OUTPUT
          else
            echo "result=false" >> $GITHUB_OUTPUT
          fi

  # Infrastructure deployment with OpenTofu
  infrastructure:
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.infra == 'true' || inputs.force_infra == true
    environment: production
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: 1.8.0

      - name: OpenTofu Init
        working-directory: packages/infra
        env:
          TF_HTTP_USERNAME: tofu
          TF_HTTP_PASSWORD: ${{ secrets.TF_HTTP_PASSWORD }}
        run: |
          tofu init

      - name: OpenTofu Validate
        working-directory: packages/infra
        run: tofu validate

      - name: Clear stale locks
        working-directory: packages/infra
        env:
          TF_HTTP_USERNAME: tofu
          TF_HTTP_PASSWORD: ${{ secrets.TF_HTTP_PASSWORD }}
        run: |
          # Check for and clear any stale locks
          echo "Checking for stale state locks..."
          LOCK_OUTPUT=$(tofu plan -no-color 2>&1 || true)
          if echo "$LOCK_OUTPUT" | grep -q "Error acquiring the state lock"; then
            # Extract lock ID from "ID=xxxxx" format
            LOCK_ID=$(echo "$LOCK_OUTPUT" | grep -oE 'ID=[a-f0-9-]+' | head -1 | cut -d= -f2)
            if [ -n "$LOCK_ID" ]; then
              echo "Found stale lock: $LOCK_ID"
              echo "Force unlocking..."
              tofu force-unlock -force "$LOCK_ID" 2>&1 || echo "Force unlock failed, will try plan with -lock=false"
            fi
          else
            echo "No stale locks found"
          fi

      - name: OpenTofu Plan
        working-directory: packages/infra
        env:
          TF_HTTP_USERNAME: tofu
          TF_HTTP_PASSWORD: ${{ secrets.TF_HTTP_PASSWORD }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_vercel_api_token: ${{ secrets.VERCEL_API_TOKEN }}
          TF_VAR_vercel_team_id: ${{ secrets.VERCEL_TEAM_ID }}
        run: |
          # Try with lock first, fall back to lock=false if stale lock exists
          tofu plan -out=tfplan -no-color -lock-timeout=30s || {
            echo "Lock timeout, retrying without lock (safe for read-only plan)..."
            tofu plan -out=tfplan -no-color -lock=false
          }

      - name: OpenTofu Apply
        working-directory: packages/infra
        env:
          TF_HTTP_USERNAME: tofu
          TF_HTTP_PASSWORD: ${{ secrets.TF_HTTP_PASSWORD }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_vercel_api_token: ${{ secrets.VERCEL_API_TOKEN }}
          TF_VAR_vercel_team_id: ${{ secrets.VERCEL_TEAM_ID }}
        run: |
          tofu apply -auto-approve tfplan

      - name: Get Server IP
        id: server
        working-directory: packages/infra
        run: |
          echo "ip=$(tofu output -raw server_ip)" >> $GITHUB_OUTPUT

    outputs:
      server_ip: ${{ steps.server.outputs.ip }}

  # Sync files to server (runs if any service changed)
  sync:
    runs-on: ubuntu-latest
    needs: [changes, infrastructure]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      needs.changes.outputs.any_service == 'true'
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.HETZNER_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Cleanup conflicting paths
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          script: |
            # Remove conflicting paths and fix permissions
            sudo rm -rf /opt/engram/configs/Caddyfile 2>/dev/null || true
            # Ensure configs directory exists with correct ownership
            sudo mkdir -p /opt/engram/configs
            sudo chown -R engram:engram /opt/engram/configs

      - name: Sync files to server
        run: |
          rsync -avz --delete --no-group --no-owner \
            --exclude '.git' \
            --exclude 'node_modules' \
            --exclude '.venv' \
            --exclude '__pycache__' \
            --exclude '*.pyc' \
            --exclude 'dist' \
            --exclude 'data' \
            --exclude '.turbo' \
            --exclude '.next' \
            --exclude '.terraform' \
            --exclude 'terraform.tfstate*' \
            . engram@${{ env.HETZNER_SERVER_IP }}:/opt/engram/

      - name: Create .env file on server
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          script: |
            cat > /opt/engram/.env << 'EOF'
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            QDRANT_COLLECTION=${{ secrets.QDRANT_COLLECTION }}
            QDRANT_TURNS_COLLECTION=${{ secrets.QDRANT_TURNS_COLLECTION }}
            HF_API_TOKEN=${{ secrets.HF_API_TOKEN }}
            EMBEDDER_BACKEND=${{ vars.EMBEDDER_BACKEND }}
            EMBEDDER_DEVICE=${{ vars.EMBEDDER_DEVICE }}
            EMBEDDER_TEXT_MODEL=${{ vars.EMBEDDER_TEXT_MODEL }}
            SEARCH_DEFAULT_STRATEGY=${{ vars.SEARCH_DEFAULT_STRATEGY }}
            CORS_ORIGINS=${{ vars.CORS_ORIGINS }}
            BETTER_AUTH_SECRET=${{ secrets.BETTER_AUTH_SECRET }}
            GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
            EOF

      - name: Run auth database migrations
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          script: |
            cd /opt/engram
            # Wait for postgres to be ready
            until docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U ${POSTGRES_USER:-engram}; do
              echo "Waiting for postgres..."
              sleep 2
            done
            # Run auth migrations on the engram database
            cat /opt/engram/scripts/migrate-auth.sql | docker compose -f docker-compose.prod.yml exec -T postgres psql -U ${POSTGRES_USER:-engram} -d engram || echo "Migration may have already been applied"

  # Deploy API service
  deploy-api:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.api == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy API
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying API..."
            docker compose -f docker-compose.prod.yml build api
            docker compose -f docker-compose.prod.yml up -d --force-recreate api
            echo "Waiting for API health check..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps api

  # Deploy Search service
  deploy-search:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.search == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Search
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying Search..."
            docker compose -f docker-compose.prod.yml build --no-cache search
            docker compose -f docker-compose.prod.yml up -d --force-recreate search
            echo "Waiting for Search health check..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps search

  # Deploy Tuner service
  deploy-tuner:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.tuner == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Tuner
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying Tuner..."
            docker compose -f docker-compose.prod.yml build --no-cache tuner
            docker compose -f docker-compose.prod.yml up -d --force-recreate tuner
            echo "Waiting for Tuner health check..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps tuner

  # Deploy Observatory service
  deploy-observatory:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.observatory == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Observatory
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying Observatory..."
            docker compose -f docker-compose.prod.yml build observatory
            docker compose -f docker-compose.prod.yml up -d --force-recreate observatory
            echo "Waiting for Observatory health check..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps observatory

  # Deploy Ingestion service
  deploy-ingestion:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.ingestion == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Ingestion
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying Ingestion..."
            docker compose -f docker-compose.prod.yml build ingestion
            docker compose -f docker-compose.prod.yml up -d --force-recreate ingestion
            echo "Waiting for Ingestion health check..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps ingestion

  # Deploy Memory service
  deploy-memory:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.memory == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Memory
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying Memory..."
            docker compose -f docker-compose.prod.yml build memory
            docker compose -f docker-compose.prod.yml up -d --force-recreate memory
            echo "Waiting for Memory startup..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps memory

  # Deploy Control service
  deploy-control:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.control == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Control
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Building and deploying Control..."
            docker compose -f docker-compose.prod.yml build control
            docker compose -f docker-compose.prod.yml up -d --force-recreate control
            echo "Waiting for Control startup..."
            sleep 5
            docker compose -f docker-compose.prod.yml ps control

  # Deploy databases/infrastructure services if docker-compose changed
  deploy-infrastructure-services:
    runs-on: ubuntu-latest
    needs: [changes, sync]
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.changes.outputs.docker_compose == 'true' || inputs.force_deploy_all == true)
    environment: production
    steps:
      - name: Deploy Infrastructure Services
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            cd /opt/engram
            echo "Creating data directories..."
            mkdir -p data/{qdrant,falkordb,postgres,nats}

            echo "Pulling infrastructure images..."
            docker compose -f docker-compose.prod.yml pull nats qdrant falkordb postgres

            echo "Starting infrastructure services..."
            docker compose -f docker-compose.prod.yml up -d nats qdrant falkordb postgres

            echo "Waiting for services to be healthy..."
            sleep 15
            docker compose -f docker-compose.prod.yml ps

  # Start Caddy reverse proxy (after all services are deployed)
  deploy-caddy:
    runs-on: ubuntu-latest
    needs:
      - sync
      - deploy-api
      - deploy-search
      - deploy-tuner
      - deploy-observatory
    if: |
      always() &&
      needs.sync.result == 'success' &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped') &&
      (needs.deploy-search.result == 'success' || needs.deploy-search.result == 'skipped') &&
      (needs.deploy-tuner.result == 'success' || needs.deploy-tuner.result == 'skipped') &&
      (needs.deploy-observatory.result == 'success' || needs.deploy-observatory.result == 'skipped')
    environment: production
    steps:
      - name: Start Caddy
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 5m
          script: |
            cd /opt/engram

            echo "Stopping all containers and removing orphans..."
            docker compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true

            echo "Killing any process on port 80/443..."
            sudo fuser -k 80/tcp 2>/dev/null || true
            sudo fuser -k 443/tcp 2>/dev/null || true
            sleep 2

            echo "Restarting docker to clear port allocations..."
            sudo systemctl restart docker
            sleep 5

            echo "Fixing data directory permissions for Docker build context..."
            sudo chmod -R a+r /opt/engram/data/ 2>/dev/null || true

            echo "Starting all services..."
            docker compose -f docker-compose.prod.yml up -d

            echo "Waiting for Caddy to be ready..."
            sleep 30
            docker compose -f docker-compose.prod.yml ps
            echo ""
            echo "Search container logs:"
            docker compose -f docker-compose.prod.yml logs --tail=30 search 2>&1 || true

  # Cleanup old Docker images
  cleanup:
    runs-on: ubuntu-latest
    needs: deploy-caddy
    if: |
      always() &&
      needs.deploy-caddy.result == 'success'
    environment: production
    steps:
      - name: Prune old Docker images
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.HETZNER_SERVER_IP }}
          username: engram
          key: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}
          command_timeout: 5m
          script: |
            echo "Pruning unused Docker images..."
            docker image prune -af
            echo ""
            echo "Pruning Docker build cache..."
            docker builder prune -af
            echo ""
            echo "Pruning unused Docker volumes..."
            docker volume prune -f
            echo ""
            echo "Pruning unused Docker networks..."
            docker network prune -f
            echo ""
            echo "Disk usage after cleanup:"
            docker system df
            df -h /

  # Summary job
  summary:
    runs-on: ubuntu-latest
    needs:
      - changes
      - infrastructure
      - sync
      - deploy-api
      - deploy-search
      - deploy-tuner
      - deploy-observatory
      - deploy-ingestion
      - deploy-memory
      - deploy-control
      - deploy-infrastructure-services
      - deploy-caddy
      - cleanup
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Changed | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.changes.outputs.infra }} | ${{ needs.infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ needs.changes.outputs.api }} | ${{ needs.deploy-api.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Search | ${{ needs.changes.outputs.search }} | ${{ needs.deploy-search.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tuner | ${{ needs.changes.outputs.tuner }} | ${{ needs.deploy-tuner.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Observatory | ${{ needs.changes.outputs.observatory }} | ${{ needs.deploy-observatory.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Ingestion | ${{ needs.changes.outputs.ingestion }} | ${{ needs.deploy-ingestion.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Memory | ${{ needs.changes.outputs.memory }} | ${{ needs.deploy-memory.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Control | ${{ needs.changes.outputs.control }} | ${{ needs.deploy-control.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Compose | ${{ needs.changes.outputs.docker_compose }} | ${{ needs.deploy-infrastructure-services.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Caddy | - | ${{ needs.deploy-caddy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service URLs" >> $GITHUB_STEP_SUMMARY
          echo "- API: https://api.statient.com" >> $GITHUB_STEP_SUMMARY
          echo "- Search: https://search.statient.com" >> $GITHUB_STEP_SUMMARY
          echo "- Tuner: https://tuner.statient.com" >> $GITHUB_STEP_SUMMARY
          echo "- Observatory: https://observatory.statient.com" >> $GITHUB_STEP_SUMMARY
