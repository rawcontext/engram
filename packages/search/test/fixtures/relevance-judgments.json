{
	"version": "1.0",
	"description": "Relevance judgments for reranker evaluation. Relevance scale: 0=Not relevant, 1=Marginally relevant, 2=Relevant, 3=Highly relevant",
	"judgments": [
		{
			"category": "code",
			"query": "how to implement authentication in Express",
			"documents": [
				{
					"id": "doc-code-1",
					"content": "To implement authentication in Express, use passport.js with a local strategy. First, install passport and passport-local: npm install passport passport-local. Then configure the strategy with your user verification logic. Example: passport.use(new LocalStrategy(async (username, password, done) => { const user = await User.findOne({ username }); if (!user || !await bcrypt.compare(password, user.password)) return done(null, false); return done(null, user); }));",
					"relevance": 3
				},
				{
					"id": "doc-code-2",
					"content": "Express.js is a minimal web application framework for Node.js. It provides a robust set of features for web and mobile applications.",
					"relevance": 0
				},
				{
					"id": "doc-code-3",
					"content": "Authentication middleware in Express can be implemented using JWT tokens. Install jsonwebtoken and create a middleware function that verifies the token on protected routes.",
					"relevance": 2
				},
				{
					"id": "doc-code-4",
					"content": "You can use express-session for session-based authentication. Configure it with a secret and store: app.use(session({ secret: 'your-secret', resave: false, saveUninitialized: false }));",
					"relevance": 2
				}
			]
		},
		{
			"category": "code",
			"query": "async/await error handling patterns",
			"documents": [
				{
					"id": "doc-code-5",
					"content": "For async/await error handling, use try-catch blocks: async function fetchData() { try { const response = await fetch(url); return await response.json(); } catch (error) { console.error('Failed to fetch:', error); throw error; } }. For Express routes, use a wrapper function or async error middleware.",
					"relevance": 3
				},
				{
					"id": "doc-code-6",
					"content": "JavaScript promises can be chained with .then() and .catch() methods for handling success and error cases.",
					"relevance": 1
				},
				{
					"id": "doc-code-7",
					"content": "The async-await syntax is syntactic sugar over promises, making asynchronous code look synchronous. Use await keyword inside async functions.",
					"relevance": 1
				},
				{
					"id": "doc-code-8",
					"content": "Best practice: Create a higher-order function to wrap async route handlers: const asyncHandler = fn => (req, res, next) => Promise.resolve(fn(req, res, next)).catch(next). Then use: router.get('/users', asyncHandler(async (req, res) => { const users = await User.find(); res.json(users); }));",
					"relevance": 3
				}
			]
		},
		{
			"category": "code",
			"query": "React hooks useEffect cleanup function",
			"documents": [
				{
					"id": "doc-code-9",
					"content": "The useEffect cleanup function is returned from the effect and runs before the component unmounts or before the effect runs again. Example: useEffect(() => { const subscription = subscribeToData(); return () => { subscription.unsubscribe(); }; }, [dependency]);",
					"relevance": 3
				},
				{
					"id": "doc-code-10",
					"content": "React hooks are functions that let you use state and other React features in functional components. Common hooks include useState, useEffect, and useContext.",
					"relevance": 1
				},
				{
					"id": "doc-code-11",
					"content": "Memory leaks in React can occur when you forget to clean up subscriptions, timers, or event listeners. Always return a cleanup function from useEffect when needed.",
					"relevance": 2
				},
				{
					"id": "doc-code-12",
					"content": "useEffect runs after every render by default. To control when it runs, pass a dependency array as the second argument. Empty array [] means it runs once on mount.",
					"relevance": 1
				}
			]
		},
		{
			"category": "code",
			"query": "TypeScript generic constraints",
			"documents": [
				{
					"id": "doc-code-13",
					"content": "TypeScript generic constraints allow you to restrict the types that can be used with a generic. Use the 'extends' keyword: function getProperty<T, K extends keyof T>(obj: T, key: K) { return obj[key]; }. This ensures K is a valid key of T.",
					"relevance": 3
				},
				{
					"id": "doc-code-14",
					"content": "Generics in TypeScript provide a way to create reusable components that work with multiple types. Syntax: function identity<T>(arg: T): T { return arg; }",
					"relevance": 1
				},
				{
					"id": "doc-code-15",
					"content": "You can constrain generics to types with specific properties: interface HasLength { length: number; } function logLength<T extends HasLength>(arg: T): void { console.log(arg.length); }",
					"relevance": 3
				},
				{
					"id": "doc-code-16",
					"content": "TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It adds optional static typing and class-based object-oriented programming.",
					"relevance": 0
				}
			]
		},
		{
			"category": "code",
			"query": "SQL query optimization indexes",
			"documents": [
				{
					"id": "doc-code-17",
					"content": "SQL query optimization with indexes: CREATE INDEX idx_user_email ON users(email); Use indexes on columns frequently used in WHERE, JOIN, and ORDER BY clauses. Check query performance with EXPLAIN ANALYZE. Composite indexes for multi-column queries: CREATE INDEX idx_user_name_age ON users(last_name, first_name, age);",
					"relevance": 3
				},
				{
					"id": "doc-code-18",
					"content": "SQL indexes speed up data retrieval but slow down INSERT, UPDATE, and DELETE operations. Balance is key.",
					"relevance": 2
				},
				{
					"id": "doc-code-19",
					"content": "SQL is a standard language for storing, manipulating and retrieving data in relational databases. Common commands include SELECT, INSERT, UPDATE, DELETE.",
					"relevance": 0
				},
				{
					"id": "doc-code-20",
					"content": "EXPLAIN and EXPLAIN ANALYZE commands show the query execution plan, revealing if indexes are being used and identifying performance bottlenecks.",
					"relevance": 2
				}
			]
		},
		{
			"category": "code",
			"query": "Python list comprehension nested loops",
			"documents": [
				{
					"id": "doc-code-21",
					"content": "Python list comprehension with nested loops: result = [(x, y) for x in range(3) for y in range(3)]. This creates all combinations. With conditions: result = [(x, y) for x in range(5) for y in range(5) if x != y]. Equivalent to nested for loops but more concise.",
					"relevance": 3
				},
				{
					"id": "doc-code-22",
					"content": "List comprehensions in Python provide a concise way to create lists: squares = [x**2 for x in range(10)]",
					"relevance": 1
				},
				{
					"id": "doc-code-23",
					"content": "Python supports nested loops like any programming language: for x in range(3): for y in range(3): print(x, y)",
					"relevance": 1
				},
				{
					"id": "doc-code-24",
					"content": "List comprehensions are generally faster than equivalent for loops in Python due to internal optimization.",
					"relevance": 1
				}
			]
		},
		{
			"category": "conceptual",
			"query": "difference between REST and GraphQL",
			"documents": [
				{
					"id": "doc-concept-1",
					"content": "REST vs GraphQL: REST uses multiple endpoints (one per resource) while GraphQL uses a single endpoint with flexible queries. REST can over-fetch or under-fetch data, requiring multiple requests. GraphQL allows clients to request exactly the data they need in one query. REST is resource-based, GraphQL is query-based. Example: REST needs /users/1 and /users/1/posts for user and posts, GraphQL gets both in one query: { user(id: 1) { name posts { title } } }",
					"relevance": 3
				},
				{
					"id": "doc-concept-2",
					"content": "REST (Representational State Transfer) is an architectural style for designing networked applications using HTTP methods: GET, POST, PUT, DELETE.",
					"relevance": 1
				},
				{
					"id": "doc-concept-3",
					"content": "GraphQL is a query language for APIs developed by Facebook. It provides a complete description of the data in your API.",
					"relevance": 1
				},
				{
					"id": "doc-concept-4",
					"content": "Both REST and GraphQL are API design patterns used for client-server communication over HTTP. The choice depends on your use case and requirements.",
					"relevance": 2
				}
			]
		},
		{
			"category": "conceptual",
			"query": "how does event loop work in Node.js",
			"documents": [
				{
					"id": "doc-concept-5",
					"content": "The Node.js event loop has 6 phases: timers (setTimeout/setInterval), pending callbacks, idle/prepare, poll (I/O operations), check (setImmediate), close callbacks. Each phase has a FIFO queue of callbacks. The poll phase is where most I/O callbacks are executed. process.nextTick() and promises are executed between phases. Event loop enables non-blocking I/O despite JavaScript being single-threaded.",
					"relevance": 3
				},
				{
					"id": "doc-concept-6",
					"content": "Node.js is built on Chrome's V8 JavaScript engine and uses an event-driven, non-blocking I/O model.",
					"relevance": 1
				},
				{
					"id": "doc-concept-7",
					"content": "The event loop allows Node.js to perform non-blocking operations by offloading operations to the system kernel whenever possible.",
					"relevance": 2
				},
				{
					"id": "doc-concept-8",
					"content": "Callback queue, microtask queue, and macrotask queue are all part of JavaScript's concurrency model in browsers and Node.js.",
					"relevance": 2
				}
			]
		},
		{
			"category": "conceptual",
			"query": "CAP theorem distributed systems",
			"documents": [
				{
					"id": "doc-concept-9",
					"content": "CAP theorem states distributed systems can only guarantee 2 of 3: Consistency (all nodes see same data), Availability (every request receives a response), Partition tolerance (system continues despite network partitions). In practice, partition tolerance is required, so choose between CP (consistent but may be unavailable) or AP (available but may be inconsistent). Examples: MongoDB is CP by default, Cassandra is AP.",
					"relevance": 3
				},
				{
					"id": "doc-concept-10",
					"content": "Distributed systems are systems whose components are located on different networked computers that communicate and coordinate by passing messages.",
					"relevance": 1
				},
				{
					"id": "doc-concept-11",
					"content": "Network partitions occur when network failures prevent some nodes from communicating with others in a distributed system.",
					"relevance": 1
				},
				{
					"id": "doc-concept-12",
					"content": "Consistency models in distributed systems include strong consistency, eventual consistency, and causal consistency, each with different trade-offs.",
					"relevance": 2
				}
			]
		},
		{
			"category": "conceptual",
			"query": "what is closure in JavaScript",
			"documents": [
				{
					"id": "doc-concept-13",
					"content": "A closure in JavaScript is a function that has access to variables in its outer (enclosing) lexical scope, even after the outer function has returned. Example: function outer() { let count = 0; return function inner() { count++; return count; }; } const counter = outer(); counter(); // 1, counter(); // 2. The inner function 'closes over' the count variable, maintaining access to it.",
					"relevance": 3
				},
				{
					"id": "doc-concept-14",
					"content": "JavaScript functions are first-class objects, meaning they can be assigned to variables, passed as arguments, and returned from other functions.",
					"relevance": 1
				},
				{
					"id": "doc-concept-15",
					"content": "Scope in JavaScript determines the accessibility of variables. There are function scope, block scope (let/const), and global scope.",
					"relevance": 1
				},
				{
					"id": "doc-concept-16",
					"content": "Closures are commonly used for data privacy, creating factory functions, and implementing partial application or currying in functional programming.",
					"relevance": 2
				}
			]
		},
		{
			"category": "conceptual",
			"query": "microservices vs monolithic architecture",
			"documents": [
				{
					"id": "doc-concept-17",
					"content": "Microservices vs Monolithic: Monolithic apps are single unified units where all components are interconnected and interdependent. Microservices break apps into small, independent services that communicate via APIs. Microservices benefits: independent deployment, technology flexibility, fault isolation, easier scaling. Drawbacks: increased complexity, network latency, distributed system challenges. Monolithic benefits: simpler development and deployment initially, easier testing, no network overhead. Choose based on team size, complexity, and scaling needs.",
					"relevance": 3
				},
				{
					"id": "doc-concept-18",
					"content": "Software architecture patterns define the overall structure of software systems and how components interact with each other.",
					"relevance": 1
				},
				{
					"id": "doc-concept-19",
					"content": "Service-oriented architecture (SOA) predates microservices and shares some concepts but differs in implementation and scope.",
					"relevance": 1
				},
				{
					"id": "doc-concept-20",
					"content": "Domain-driven design (DDD) principles are often used when designing microservices to define bounded contexts and service boundaries.",
					"relevance": 2
				}
			]
		},
		{
			"category": "api",
			"query": "how to use Array.reduce in JavaScript",
			"documents": [
				{
					"id": "doc-api-1",
					"content": "Array.reduce() executes a reducer function on each array element, resulting in a single output value. Syntax: array.reduce((accumulator, currentValue, currentIndex, array) => { return accumulator; }, initialValue). Example sum: [1,2,3,4].reduce((sum, num) => sum + num, 0) // 10. Example grouping: items.reduce((acc, item) => { acc[item.category] = acc[item.category] || []; acc[item.category].push(item); return acc; }, {})",
					"relevance": 3
				},
				{
					"id": "doc-api-2",
					"content": "JavaScript Array methods include map, filter, reduce, forEach, find, some, every, and more. These are higher-order functions for array manipulation.",
					"relevance": 1
				},
				{
					"id": "doc-api-3",
					"content": "The accumulator in reduce() is the value returned from the previous iteration. The initial value is optional but recommended to avoid errors on empty arrays.",
					"relevance": 2
				},
				{
					"id": "doc-api-4",
					"content": "Functional programming in JavaScript emphasizes pure functions, immutability, and function composition. Array methods like reduce are key tools.",
					"relevance": 1
				}
			]
		},
		{
			"category": "api",
			"query": "Fetch API error handling",
			"documents": [
				{
					"id": "doc-api-5",
					"content": "Fetch API error handling: fetch() only rejects on network errors, not HTTP errors (4xx, 5xx). Check response.ok: fetch(url).then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response.json(); }).catch(error => console.error('Fetch error:', error)). For timeout: use AbortController with setTimeout.",
					"relevance": 3
				},
				{
					"id": "doc-api-6",
					"content": "The Fetch API provides a JavaScript interface for accessing and manipulating HTTP requests and responses. It returns a Promise.",
					"relevance": 1
				},
				{
					"id": "doc-api-7",
					"content": "HTTP status codes: 2xx (success), 3xx (redirection), 4xx (client errors), 5xx (server errors). Common codes: 200 OK, 404 Not Found, 500 Internal Server Error.",
					"relevance": 1
				},
				{
					"id": "doc-api-8",
					"content": "Alternative to fetch: axios library provides automatic error handling for HTTP errors and has a simpler API. It throws on any error status code.",
					"relevance": 2
				}
			]
		},
		{
			"category": "api",
			"query": "React Router useNavigate hook",
			"documents": [
				{
					"id": "doc-api-9",
					"content": "useNavigate hook (React Router v6+) enables programmatic navigation. Usage: const navigate = useNavigate(); navigate('/path'); navigate('/path', { replace: true }); navigate(-1) // go back; navigate(2) // go forward 2 pages. Pass state: navigate('/path', { state: { from: 'login' } }). Replaces useHistory from v5.",
					"relevance": 3
				},
				{
					"id": "doc-api-10",
					"content": "React Router is a standard library for routing in React applications. It keeps your UI in sync with the URL.",
					"relevance": 1
				},
				{
					"id": "doc-api-11",
					"content": "React Router v6 introduced several breaking changes from v5, including replacing Switch with Routes and useHistory with useNavigate.",
					"relevance": 2
				},
				{
					"id": "doc-api-12",
					"content": "Navigation in single-page applications can be done programmatically (using functions) or declaratively (using Link components).",
					"relevance": 1
				}
			]
		},
		{
			"category": "api",
			"query": "Express middleware order and next()",
			"documents": [
				{
					"id": "doc-api-13",
					"content": "Express middleware executes in the order defined. Each middleware must call next() to pass control to the next middleware or send a response. Order matters: app.use(cors()); app.use(express.json()); app.use(auth); Routes are also middleware. Error-handling middleware has 4 parameters: (err, req, res, next) and must be defined last. If next(err) is called, it skips to error middleware.",
					"relevance": 3
				},
				{
					"id": "doc-api-14",
					"content": "Express.js middleware functions have access to request (req), response (res), and next function. They can execute code, modify req/res, end the request, or call next().",
					"relevance": 2
				},
				{
					"id": "doc-api-15",
					"content": "Common Express middleware includes body-parser, cors, helmet for security, morgan for logging, and serve-static for serving files.",
					"relevance": 1
				},
				{
					"id": "doc-api-16",
					"content": "The Express request-response cycle ends when a middleware sends a response using res.send(), res.json(), res.render(), etc.",
					"relevance": 1
				}
			]
		},
		{
			"category": "api",
			"query": "MongoDB aggregation pipeline",
			"documents": [
				{
					"id": "doc-api-17",
					"content": "MongoDB aggregation pipeline processes documents through stages. Common stages: $match (filter), $group (group by field), $project (reshape documents), $sort, $limit, $lookup (join), $unwind (deconstruct arrays). Example: db.orders.aggregate([{ $match: { status: 'completed' }}, { $group: { _id: '$customerId', total: { $sum: '$amount' }}}, { $sort: { total: -1 }}, { $limit: 10 }]). Each stage transforms documents, output becomes input for next stage.",
					"relevance": 3
				},
				{
					"id": "doc-api-18",
					"content": "MongoDB is a NoSQL document database that stores data in flexible, JSON-like documents. It's designed for scalability and developer agility.",
					"relevance": 0
				},
				{
					"id": "doc-api-19",
					"content": "Aggregation frameworks in databases allow for complex data processing and analysis beyond simple CRUD operations.",
					"relevance": 1
				},
				{
					"id": "doc-api-20",
					"content": "The $lookup stage in MongoDB aggregation is similar to SQL JOIN, allowing you to combine documents from different collections.",
					"relevance": 2
				}
			]
		},
		{
			"category": "debugging",
			"query": "debugging CORS errors in development",
			"documents": [
				{
					"id": "doc-debug-1",
					"content": "CORS errors occur when browser blocks requests from different origins. Solutions: 1) Backend: Install cors middleware: npm i cors; app.use(cors({ origin: 'http://localhost:3000', credentials: true })); 2) Development proxy: In package.json add \"proxy\": \"http://localhost:5000\" or use http-proxy-middleware. 3) Check Access-Control-Allow-Origin header in response. Browser console shows specific CORS error (missing header, credentials, method not allowed).",
					"relevance": 3
				},
				{
					"id": "doc-debug-2",
					"content": "CORS (Cross-Origin Resource Sharing) is a security feature implemented by browsers to restrict cross-origin HTTP requests initiated from scripts.",
					"relevance": 1
				},
				{
					"id": "doc-debug-3",
					"content": "Same-origin policy is a critical security mechanism that restricts how a document or script from one origin can interact with resources from another origin.",
					"relevance": 1
				},
				{
					"id": "doc-debug-4",
					"content": "Preflight requests (OPTIONS) are sent by browsers before certain CORS requests to check if the actual request is safe to send.",
					"relevance": 2
				}
			]
		},
		{
			"category": "debugging",
			"query": "memory leak detection in Node.js",
			"documents": [
				{
					"id": "doc-debug-5",
					"content": "Detect Node.js memory leaks: 1) Use --inspect flag: node --inspect app.js, open chrome://inspect, take heap snapshots over time, compare snapshots in Memory tab. 2) clinic.js: npm i -g clinic; clinic doctor -- node app.js. 3) Process monitoring: process.memoryUsage() to log heap usage. Common causes: global variables, event listeners not removed, closures holding references, timers not cleared. Look for detached DOM nodes, abandoned callbacks, growing arrays.",
					"relevance": 3
				},
				{
					"id": "doc-debug-6",
					"content": "Memory leaks occur when allocated memory is not freed after it's no longer needed, gradually consuming available memory until the program crashes.",
					"relevance": 1
				},
				{
					"id": "doc-debug-7",
					"content": "Node.js uses V8's garbage collector which automatically frees memory for objects that are no longer referenced.",
					"relevance": 1
				},
				{
					"id": "doc-debug-8",
					"content": "Tools for profiling Node.js applications include Chrome DevTools, clinic.js, 0x for flame graphs, and autocannon for load testing.",
					"relevance": 2
				}
			]
		},
		{
			"category": "debugging",
			"query": "fixing TypeError: Cannot read property of undefined",
			"documents": [
				{
					"id": "doc-debug-9",
					"content": "TypeError: Cannot read property 'x' of undefined means you're trying to access property 'x' on undefined. Solutions: 1) Optional chaining: obj?.prop?.subprop instead of obj.prop.subprop. 2) Check existence: if (obj && obj.prop) { ... }. 3) Default values: const value = obj?.prop ?? 'default'. 4) Nullish coalescing: const x = obj?.prop ?? fallback. Check API response structure, ensure data is loaded before accessing, use TypeScript for compile-time checks.",
					"relevance": 3
				},
				{
					"id": "doc-debug-10",
					"content": "JavaScript TypeError is thrown when an operation could not be performed because a value is not of the expected type.",
					"relevance": 1
				},
				{
					"id": "doc-debug-11",
					"content": "undefined in JavaScript means a variable has been declared but not assigned a value, or a property doesn't exist on an object.",
					"relevance": 1
				},
				{
					"id": "doc-debug-12",
					"content": "Defensive programming techniques include input validation, null checks, default values, and graceful error handling to prevent runtime errors.",
					"relevance": 2
				}
			]
		},
		{
			"category": "debugging",
			"query": "React useState not updating immediately",
			"documents": [
				{
					"id": "doc-debug-13",
					"content": "React useState updates are asynchronous and batched. The state variable doesn't update immediately after setState. Solutions: 1) Use functional update form: setCount(prev => prev + 1) for updates based on previous state. 2) Use useEffect to respond to state changes: useEffect(() => { console.log(count); }, [count]). 3) Multiple setState calls in same render are batched. Don't rely on state value immediately after setState. If you need the new value, calculate it: const newCount = count + 1; setCount(newCount); use newCount.",
					"relevance": 3
				},
				{
					"id": "doc-debug-14",
					"content": "React useState is a Hook that lets you add state to functional components. It returns an array with current state and a setter function.",
					"relevance": 1
				},
				{
					"id": "doc-debug-15",
					"content": "React batches state updates for performance, meaning multiple setState calls in the same event handler are processed together in a single re-render.",
					"relevance": 2
				},
				{
					"id": "doc-debug-16",
					"content": "React 18 introduced automatic batching for all updates, including those in promises, setTimeout, and native event handlers.",
					"relevance": 1
				}
			]
		},
		{
			"category": "debugging",
			"query": "SQL query running slow performance issues",
			"documents": [
				{
					"id": "doc-debug-17",
					"content": "SQL query slow? Diagnose and fix: 1) Use EXPLAIN ANALYZE to see execution plan. 2) Add indexes on WHERE, JOIN, ORDER BY columns. 3) Avoid SELECT *, only fetch needed columns. 4) Use LIMIT for pagination. 5) Check for table scans (bad), want index scans (good). 6) Optimize JOINs: ensure foreign keys have indexes. 7) Use UNION ALL instead of UNION if duplicates ok. 8) Check for N+1 queries, use JOINs or batch loading. 9) Denormalize for read-heavy workloads. 10) Consider query result caching.",
					"relevance": 3
				},
				{
					"id": "doc-debug-18",
					"content": "Database performance tuning involves optimizing queries, indexes, schema design, and configuration to improve response times.",
					"relevance": 2
				},
				{
					"id": "doc-debug-19",
					"content": "Table scans are expensive operations where the database reads every row. Indexes help avoid full table scans by providing quick lookup paths.",
					"relevance": 2
				},
				{
					"id": "doc-debug-20",
					"content": "EXPLAIN shows the query execution plan without running the query, while EXPLAIN ANALYZE actually executes it and shows real timing data.",
					"relevance": 2
				}
			]
		},
		{
			"category": "general",
			"query": "best practices for API versioning",
			"documents": [
				{
					"id": "doc-general-1",
					"content": "API versioning strategies: 1) URI versioning: /api/v1/users (most common, clear). 2) Header versioning: Accept: application/vnd.api.v1+json (cleaner URLs). 3) Query parameter: /api/users?version=1 (flexible). Best practices: Use semantic versioning, support old versions with deprecation timeline, version breaking changes only, document changes clearly, use API gateway for routing. Don't version too frequently. Stripe and GitHub use URI versioning with date-based versions.",
					"relevance": 3
				},
				{
					"id": "doc-general-2",
					"content": "API design involves creating interfaces that are easy to use, understand, and maintain. Good APIs are consistent, well-documented, and follow standards.",
					"relevance": 1
				},
				{
					"id": "doc-general-3",
					"content": "Breaking changes in APIs include removing endpoints, changing response structure, requiring new required fields, or changing data types.",
					"relevance": 2
				},
				{
					"id": "doc-general-4",
					"content": "Semantic versioning uses MAJOR.MINOR.PATCH format where MAJOR is for breaking changes, MINOR for backwards-compatible features, PATCH for bug fixes.",
					"relevance": 2
				}
			]
		},
		{
			"category": "general",
			"query": "git rebase vs merge when to use",
			"documents": [
				{
					"id": "doc-general-5",
					"content": "Git rebase vs merge: Merge creates a merge commit, preserving branch history (branching structure visible). Rebase moves commits to new base, creating linear history (cleaner but rewrites history). Use merge for: public branches, preserving exact history, feature branches merged to main. Use rebase for: updating feature branch with main changes, cleaning up local commits before PR, maintaining linear history. Golden rule: NEVER rebase public/shared branches. Workflow: rebase locally, merge to main. Example: git checkout feature; git rebase main; git checkout main; git merge feature.",
					"relevance": 3
				},
				{
					"id": "doc-general-6",
					"content": "Git is a distributed version control system for tracking changes in source code. It enables collaboration and maintains project history.",
					"relevance": 0
				},
				{
					"id": "doc-general-7",
					"content": "Merge conflicts occur when Git cannot automatically resolve differences between branches. They must be resolved manually.",
					"relevance": 1
				},
				{
					"id": "doc-general-8",
					"content": "Git workflow strategies include Git Flow, GitHub Flow, and Trunk-Based Development, each with different branching patterns.",
					"relevance": 1
				}
			]
		},
		{
			"category": "general",
			"query": "difference between unit and integration tests",
			"documents": [
				{
					"id": "doc-general-9",
					"content": "Unit vs Integration tests: Unit tests test individual functions/components in isolation, mocking dependencies. Fast, numerous (70-80% of tests), catch logic errors early. Example: testing a pure function with different inputs. Integration tests test how multiple components work together with real dependencies. Slower, fewer (20-30%), catch interface issues. Example: testing API endpoint with real database. Use test pyramid: many unit tests, some integration tests, few E2E tests. Jest/Mocha for unit, Supertest/TestContainers for integration.",
					"relevance": 3
				},
				{
					"id": "doc-general-10",
					"content": "Software testing ensures code quality and correctness. Types include unit, integration, end-to-end, performance, and security testing.",
					"relevance": 1
				},
				{
					"id": "doc-general-11",
					"content": "Test-driven development (TDD) is a methodology where tests are written before implementation code. The cycle is: write test, fail, implement, pass, refactor.",
					"relevance": 1
				},
				{
					"id": "doc-general-12",
					"content": "Mocking and stubbing are techniques used in testing to replace real dependencies with controlled test doubles.",
					"relevance": 2
				}
			]
		},
		{
			"category": "general",
			"query": "OAuth 2.0 flow explained",
			"documents": [
				{
					"id": "doc-general-13",
					"content": "OAuth 2.0 authorization flow: 1) Client redirects user to authorization server with client_id, redirect_uri, scope. 2) User authenticates and grants permission. 3) Auth server redirects back with authorization code. 4) Client exchanges code for access token (with client_secret, server-side only). 5) Client uses access token to access protected resources. Grant types: Authorization Code (web apps), Implicit (deprecated), Client Credentials (machine-to-machine), PKCE (mobile/SPA). Refresh tokens for long-lived access. OAuth is for authorization, not authentication (use OpenID Connect for auth).",
					"relevance": 3
				},
				{
					"id": "doc-general-14",
					"content": "OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on HTTP services.",
					"relevance": 2
				},
				{
					"id": "doc-general-15",
					"content": "Access tokens are credentials used to access protected resources. They should be short-lived and stored securely.",
					"relevance": 1
				},
				{
					"id": "doc-general-16",
					"content": "OpenID Connect is an authentication layer built on top of OAuth 2.0, adding identity verification through ID tokens.",
					"relevance": 2
				}
			]
		},
		{
			"category": "general",
			"query": "Docker vs virtual machines",
			"documents": [
				{
					"id": "doc-general-17",
					"content": "Docker vs VMs: VMs virtualize hardware, include full OS, managed by hypervisor. Heavy (GBs), slow startup (minutes), strong isolation. Docker uses containerization, shares host OS kernel, lightweight (MBs), fast startup (seconds), process-level isolation. Containers are portable across any host running Docker. VMs better for: running different OS, maximum isolation, running legacy apps. Containers better for: microservices, CI/CD, dev/prod parity, resource efficiency. Can combine: run Docker inside VMs for extra isolation.",
					"relevance": 3
				},
				{
					"id": "doc-general-18",
					"content": "Virtualization technology allows multiple operating systems to run on a single physical machine by abstracting hardware resources.",
					"relevance": 1
				},
				{
					"id": "doc-general-19",
					"content": "Docker is a platform for developing, shipping, and running applications in containers. It packages applications with dependencies.",
					"relevance": 1
				},
				{
					"id": "doc-general-20",
					"content": "Container orchestration platforms like Kubernetes manage deployment, scaling, and networking of containerized applications.",
					"relevance": 2
				}
			]
		}
	]
}
