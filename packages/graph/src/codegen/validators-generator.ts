/**
 * Zod Validator Generator for Schema DSL
 *
 * Generates Zod schemas from schema DSL node and edge definitions.
 * The generated validators provide runtime input validation for API endpoints and MCP tools.
 *
 * @example
 * ```typescript
 * import { generateValidators } from './validators-generator';
 * import { engramSchema } from '../schema';
 *
 * const code = generateValidators(engramSchema);
 * await Bun.write('src/generated/validators.ts', code);
 * ```
 *
 * @see packages/graph/src/models/nodes.ts - Existing Zod patterns
 */

import type { EdgeDefinition } from "../schema/edge";
import type { NodeDefinition } from "../schema/node";
import type { Schema } from "../schema/schema";
import type { Field } from "../schema/types";

// =============================================================================
// Generator Configuration
// =============================================================================

export interface GeneratorConfig {
	/**
	 * Whether to include type exports (z.infer<typeof Schema>).
	 * Set to false when types.ts is also generated to avoid duplicate exports.
	 * @default false
	 */
	includeTypes?: boolean;

	/**
	 * Whether to generate CreateXXXInputSchema (omits id and bitemporal fields).
	 * @default true
	 */
	generateCreateInputs?: boolean;

	/**
	 * Whether to generate UpdateXXXInputSchema (partial of create input).
	 * @default true
	 */
	generateUpdateInputs?: boolean;

	/**
	 * Whether to generate edge property schemas.
	 * @default true
	 */
	generateEdgeSchemas?: boolean;

	/**
	 * Header comment for generated file.
	 */
	header?: string;
}

const DEFAULT_CONFIG: Required<GeneratorConfig> = {
	includeTypes: false,
	generateCreateInputs: true,
	generateUpdateInputs: true,
	generateEdgeSchemas: true,
	header: "// AUTO-GENERATED FILE - DO NOT EDIT\n// Generated by validators-generator.ts\n",
};

// =============================================================================
// Field to Zod Mapping
// =============================================================================

/**
 * Convert a Field definition to its Zod schema code.
 */
function fieldToZod(fieldDef: Field): string {
	const kind = fieldDef.kind;
	const config = fieldDef.config;

	let zodCode: string;

	switch (kind) {
		case "string": {
			zodCode = "z.string()";
			const maxLength = (config as { maxLength?: number }).maxLength;
			if (maxLength !== undefined) {
				zodCode += `.max(${maxLength})`;
			}
			break;
		}
		case "int": {
			zodCode = "z.number().int()";
			const intConfig = config as { min?: number; max?: number };
			if (intConfig.min !== undefined) {
				zodCode += `.min(${intConfig.min})`;
			}
			if (intConfig.max !== undefined) {
				zodCode += `.max(${intConfig.max})`;
			}
			break;
		}
		case "float": {
			zodCode = "z.number()";
			const floatConfig = config as { min?: number; max?: number };
			if (floatConfig.min !== undefined) {
				zodCode += `.min(${floatConfig.min})`;
			}
			if (floatConfig.max !== undefined) {
				zodCode += `.max(${floatConfig.max})`;
			}
			break;
		}
		case "boolean": {
			zodCode = "z.boolean()";
			break;
		}
		case "timestamp": {
			zodCode = "z.number()";
			break;
		}
		case "array": {
			const arrayConfig = config as { inner: Field };
			const innerZod = fieldToZod(arrayConfig.inner);
			zodCode = `z.array(${innerZod})`;
			break;
		}
		case "enum": {
			const enumConfig = config as { values: readonly string[] };
			const enumValues = enumConfig.values.map((v) => `"${v}"`).join(", ");
			zodCode = `z.enum([${enumValues}])`;
			break;
		}
		case "vector": {
			zodCode = "z.array(z.number())";
			break;
		}
		default: {
			zodCode = "z.unknown()";
		}
	}

	// Handle modifiers
	if (config.defaultValue !== undefined) {
		const defaultVal =
			typeof config.defaultValue === "string"
				? `"${config.defaultValue}"`
				: Array.isArray(config.defaultValue)
					? JSON.stringify(config.defaultValue)
					: String(config.defaultValue);
		zodCode += `.default(${defaultVal})`;
	}

	if (config.optional === true) {
		zodCode += ".optional()";
	}

	return zodCode;
}

// =============================================================================
// Schema Generation
// =============================================================================

/**
 * Generate Zod schema code for a single node definition.
 */
function generateNodeSchema(
	nodeName: string,
	nodeDef: NodeDefinition<Record<string, Field>, boolean>,
	config: Required<GeneratorConfig>,
): string {
	const lines: string[] = [];

	// Main schema
	lines.push(`export const ${nodeName}Schema = z.object({`);
	lines.push(`\tid: z.string(),`);

	for (const [fieldName, fieldDef] of Object.entries(nodeDef.fields)) {
		// Skip id as we add it explicitly
		if (fieldName === "id") continue;
		lines.push(`\t${fieldName}: ${fieldToZod(fieldDef)},`);
	}

	// Add bitemporal fields if enabled
	if (nodeDef.config.bitemporal) {
		lines.push(`}).merge(BitemporalSchema);`);
	} else {
		lines.push(`});`);
	}

	lines.push("");

	// Generate CreateInputSchema (omits id and bitemporal)
	if (config.generateCreateInputs) {
		lines.push(`export const Create${nodeName}InputSchema = ${nodeName}Schema.omit({`);
		lines.push(`\tid: true,`);
		if (nodeDef.config.bitemporal) {
			lines.push(`\tvt_start: true,`);
			lines.push(`\tvt_end: true,`);
			lines.push(`\ttt_start: true,`);
			lines.push(`\ttt_end: true,`);
		}
		lines.push(`});`);
		lines.push("");
	}

	// Generate UpdateInputSchema (partial of create)
	if (config.generateUpdateInputs && config.generateCreateInputs) {
		lines.push(
			`export const Update${nodeName}InputSchema = Create${nodeName}InputSchema.partial();`,
		);
		lines.push("");
	}

	// Generate type exports
	if (config.includeTypes) {
		lines.push(`export type ${nodeName} = z.infer<typeof ${nodeName}Schema>;`);
		if (config.generateCreateInputs) {
			lines.push(
				`export type Create${nodeName}Input = z.infer<typeof Create${nodeName}InputSchema>;`,
			);
		}
		if (config.generateUpdateInputs && config.generateCreateInputs) {
			lines.push(
				`export type Update${nodeName}Input = z.infer<typeof Update${nodeName}InputSchema>;`,
			);
		}
		lines.push("");
	}

	return lines.join("\n");
}

/**
 * Generate Zod schema code for edge properties.
 */
function generateEdgeSchema(
	edgeName: string,
	edgeDef: EdgeDefinition<Record<string, Field>>,
	config: Required<GeneratorConfig>,
): string {
	if (!edgeDef.hasProperties()) {
		return "";
	}

	const lines: string[] = [];
	const props = edgeDef.getProperties();

	lines.push(`export const ${edgeName}PropertiesSchema = z.object({`);

	for (const [fieldName, fieldDef] of Object.entries(props)) {
		lines.push(`\t${fieldName}: ${fieldToZod(fieldDef)},`);
	}

	// Add bitemporal fields if edge is temporal
	if (edgeDef.isTemporal()) {
		lines.push(`}).merge(BitemporalSchema);`);
	} else {
		lines.push(`});`);
	}

	lines.push("");

	if (config.includeTypes) {
		lines.push(`export type ${edgeName}Properties = z.infer<typeof ${edgeName}PropertiesSchema>;`);
		lines.push("");
	}

	return lines.join("\n");
}

// =============================================================================
// Main Generator
// =============================================================================

/**
 * Generate Zod validators from a complete schema definition.
 *
 * @param schema - The schema to generate validators for
 * @param config - Generator configuration
 * @returns Generated TypeScript code as a string
 *
 * @example
 * ```typescript
 * import { generateValidators } from './validators-generator';
 * import { engramSchema } from '../schema';
 *
 * const code = generateValidators(engramSchema);
 * await Bun.write('src/generated/validators.ts', code);
 * ```
 */
export function generateValidators(
	schema: Schema<Record<string, NodeDefinition<any, any>>, Record<string, EdgeDefinition<any>>>,
	config: Partial<GeneratorConfig> = {},
): string {
	const finalConfig = { ...DEFAULT_CONFIG, ...config };
	const lines: string[] = [];

	// Header
	lines.push(finalConfig.header);
	lines.push("");

	// Imports
	lines.push('import { z } from "zod";');
	lines.push("");

	// Bitemporal schema (always needed for merge)
	lines.push("// =============================================================================");
	lines.push("// Bitemporal Schema");
	lines.push("// =============================================================================");
	lines.push("");
	lines.push("export const BitemporalSchema = z.object({");
	lines.push("\tvt_start: z.number(),");
	lines.push("\tvt_end: z.number(),");
	lines.push("\ttt_start: z.number(),");
	lines.push("\ttt_end: z.number(),");
	lines.push("});");
	lines.push("");
	lines.push("export type Bitemporal = z.infer<typeof BitemporalSchema>;");
	lines.push("");

	// Node schemas
	lines.push("// =============================================================================");
	lines.push("// Node Schemas");
	lines.push("// =============================================================================");
	lines.push("");

	for (const [nodeName, nodeDef] of Object.entries(schema.nodes)) {
		lines.push(generateNodeSchema(nodeName, nodeDef, finalConfig));
	}

	// Edge property schemas
	if (finalConfig.generateEdgeSchemas) {
		const edgesWithProps = Object.entries(schema.edges).filter(([_, edgeDef]) =>
			edgeDef.hasProperties(),
		);

		if (edgesWithProps.length > 0) {
			lines.push(
				"// =============================================================================",
			);
			lines.push("// Edge Property Schemas");
			lines.push(
				"// =============================================================================",
			);
			lines.push("");

			for (const [edgeName, edgeDef] of edgesWithProps) {
				lines.push(generateEdgeSchema(edgeName, edgeDef, finalConfig));
			}
		}
	}

	return lines.join("\n");
}

/**
 * Generate validators and write to a file.
 *
 * @param schema - The schema to generate validators for
 * @param outputPath - Path to write the generated file
 * @param config - Generator configuration
 */
export async function generateValidatorsToFile(
	schema: Schema<Record<string, NodeDefinition<any, any>>, Record<string, EdgeDefinition<any>>>,
	outputPath: string,
	config: Partial<GeneratorConfig> = {},
): Promise<void> {
	const code = generateValidators(schema, config);
	await Bun.write(outputPath, code);
}
