import { describe, expect, test } from "bun:test";
import { edge } from "../schema/edge";
import { field } from "../schema/field";
import { node } from "../schema/node";
import { defineSchema } from "../schema/schema";
import { generateRepositories } from "./repository-generator";

// Test schemas
const MemoryTypes = ["decision", "context", "insight", "preference", "fact"] as const;

const MemoryNode = node({
	content: field.string(),
	contentHash: field.string(),
	type: field.enum(MemoryTypes),
	tags: field.array(field.string()),
	sourceSessionId: field.string().optional(),
	project: field.string().optional(),
	embedding: field.vector(1024).optional(),
});

const SessionNode = node({
	userId: field.string(),
	startedAt: field.timestamp(),
	agentType: field.enum(["claude-code", "codex", "unknown"] as const).default("unknown"),
	summary: field.string().optional(),
});

const EntityNode = node({
	name: field.string(),
	aliases: field.array(field.string()),
	type: field.enum(["person", "organization", "tool", "concept"] as const),
});

const HasTurn = edge({
	from: "Session",
	to: "Turn",
});

const Mentions = edge({
	from: "Memory",
	to: "Entity",
	properties: {
		confidence: field.float(),
		context: field.string().optional(),
	},
});

const simpleSchema = defineSchema({
	nodes: {
		Memory: MemoryNode,
	},
	edges: {},
});

const fullSchema = defineSchema({
	nodes: {
		Memory: MemoryNode,
		Session: SessionNode,
		Entity: EntityNode,
	},
	edges: {
		HAS_TURN: HasTurn,
		MENTIONS: Mentions,
	},
});

describe("generateRepositories", () => {
	describe("header generation", () => {
		test("includes auto-generated header by default", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("// AUTO-GENERATED FILE - DO NOT EDIT");
			expect(code).toContain("// Generated by repository-generator.ts");
		});

		test("allows custom header", () => {
			const code = generateRepositories(simpleSchema, {
				includeHeader: "// Custom header\n",
			});
			expect(code).toContain("// Custom header");
			expect(code).not.toContain("// AUTO-GENERATED");
		});

		test("can disable header", () => {
			const code = generateRepositories(simpleSchema, {
				includeHeader: false,
			});
			expect(code).not.toContain("// AUTO-GENERATED");
		});
	});

	describe("imports", () => {
		test("includes required imports", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("import type { TenantContext }");
			expect(code).toContain("import type { FalkorNode, GraphClient }");
			expect(code).toContain("import { TenantAwareFalkorClient }");
			expect(code).toContain("import { FalkorBaseRepository");
		});

		test("imports types for each node", () => {
			const code = generateRepositories(fullSchema);
			expect(code).toContain("import type { Memory, CreateMemoryInput, UpdateMemoryInput }");
			expect(code).toContain("import type { Session, CreateSessionInput, UpdateSessionInput }");
			expect(code).toContain("import type { Entity, CreateEntityInput, UpdateEntityInput }");
		});
	});

	describe("node props types", () => {
		test("generates node props type for each node", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("type MemoryNodeProps = {");
			expect(code).toContain("id: string;");
		});

		test("converts camelCase fields to snake_case", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("content_hash");
			expect(code).toContain("source_session_id");
		});

		test("includes bitemporal fields", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("vt_start: number;");
			expect(code).toContain("vt_end: number;");
			expect(code).toContain("tt_start: number;");
			expect(code).toContain("tt_end: number;");
		});

		test("marks optional fields with ?", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("source_session_id?:");
			expect(code).toContain("project?:");
			expect(code).toContain("embedding?:");
		});
	});

	describe("repository class generation", () => {
		test("generates repository class for each node", () => {
			const code = generateRepositories(fullSchema);
			expect(code).toContain("export class FalkorMemoryRepository extends FalkorBaseRepository");
			expect(code).toContain("export class FalkorSessionRepository extends FalkorBaseRepository");
			expect(code).toContain("export class FalkorEntityRepository extends FalkorBaseRepository");
		});

		test("includes JSDoc comments by default", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("/**");
			expect(code).toContain(" * FalkorDB repository implementation for Memory nodes.");
		});

		test("can disable comments", () => {
			const code = generateRepositories(simpleSchema, { includeComments: false });
			expect(code).not.toContain(" * FalkorDB repository implementation");
		});
	});

	describe("findById method", () => {
		test("generates findById method", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async findById(id: string): Promise<Memory | null>");
			expect(code).toContain("MATCH (n:Memory {id: $id})");
			expect(code).toContain("WHERE n.tt_end = ${this.maxDate}");
		});
	});

	describe("findActive method", () => {
		test("generates findActive method", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async findActive(): Promise<Memory[]>");
			expect(code).toContain("MATCH (n:Memory)");
			expect(code).toContain("ORDER BY n.vt_start DESC");
		});
	});

	describe("temporal queries", () => {
		test("generates findByIdAt method", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async findByIdAt(id: string, options: TimeTravelOptions)");
			expect(code).toContain("n.vt_start <= $vt AND n.vt_end > $vt");
			expect(code).toContain("n.tt_start <= $tt AND n.tt_end > $tt");
		});

		test("can disable temporal queries", () => {
			const code = generateRepositories(simpleSchema, { generateTemporalQueries: false });
			expect(code).not.toContain("findByIdAt");
		});
	});

	describe("field-specific finders", () => {
		test("generates findBy methods for enum fields", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async findByType(value:");
			expect(code).toContain('"decision" | "context" | "insight" | "preference" | "fact"');
		});

		test("generates findBy methods for foreign key fields", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async findBySourceSessionId(value: string)");
		});

		test("can disable field finders", () => {
			const code = generateRepositories(simpleSchema, { generateFieldFinders: false });
			expect(code).not.toContain("findByType");
			expect(code).not.toContain("findBySourceSessionId");
		});
	});

	describe("create method", () => {
		test("generates create method", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async create(input: CreateMemoryInput): Promise<Memory>");
			expect(code).toContain("const id = this.generateId()");
			expect(code).toContain("const temporal = this.createBitemporal()");
		});

		test("handles required and optional fields", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("content: input.content,");
			expect(code).toContain("if (input.sourceSessionId !== undefined)");
		});

		test("handles default values", () => {
			const code = generateRepositories(fullSchema);
			// Session has agentType with default
			expect(code).toContain('input.agentType ?? "unknown"');
		});

		test("can disable create generation", () => {
			const code = generateRepositories(simpleSchema, { generateCreate: false });
			expect(code).not.toContain("async create(input:");
		});
	});

	describe("update method", () => {
		test("generates update method with temporal versioning", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain(
				"async update(id: string, updates: UpdateMemoryInput): Promise<Memory>",
			);
			expect(code).toContain("// Expire current version");
			expect(code).toContain("SET n.tt_end = $now");
			expect(code).toContain("// Create new version with updates");
		});

		test("can disable update generation", () => {
			const code = generateRepositories(simpleSchema, { generateUpdate: false });
			expect(code).not.toContain("async update(id:");
		});
	});

	describe("delete method", () => {
		test("generates soft delete method", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("async delete(id: string): Promise<boolean>");
			expect(code).toContain("SET n.tt_end = $now, n.vt_end = $now");
		});

		test("can disable delete generation", () => {
			const code = generateRepositories(simpleSchema, { generateDelete: false });
			expect(code).not.toContain("async delete(id:");
		});
	});

	describe("mapping method", () => {
		test("generates private mapping method", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("private mapToMemory(node: FalkorNode<MemoryNodeProps>): Memory");
		});

		test("maps snake_case to camelCase", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("contentHash: props.content_hash,");
			expect(code).toContain("sourceSessionId: props.source_session_id,");
		});

		test("maps bitemporal fields", () => {
			const code = generateRepositories(simpleSchema);
			expect(code).toContain("vtStart: props.vt_start,");
			expect(code).toContain("vtEnd: props.vt_end,");
			expect(code).toContain("ttStart: props.tt_start,");
			expect(code).toContain("ttEnd: props.tt_end,");
		});
	});

	describe("repository factory", () => {
		test("generates createRepositories factory function", () => {
			const code = generateRepositories(fullSchema);
			expect(code).toContain("export function createRepositories(");
			expect(code).toContain("client: GraphClient | TenantAwareFalkorClient,");
			expect(code).toContain("tenantContext?: TenantContext,");
		});

		test("returns object with all repositories", () => {
			const code = generateRepositories(fullSchema);
			expect(code).toContain("memory: FalkorMemoryRepository;");
			expect(code).toContain("session: FalkorSessionRepository;");
			expect(code).toContain("entity: FalkorEntityRepository;");
		});

		test("instantiates repositories correctly", () => {
			const code = generateRepositories(fullSchema);
			expect(code).toContain("memory: new FalkorMemoryRepository(client, tenantContext),");
			expect(code).toContain("session: new FalkorSessionRepository(client, tenantContext),");
			expect(code).toContain("entity: new FalkorEntityRepository(client, tenantContext),");
		});
	});

	describe("full schema generation", () => {
		test("generates valid TypeScript for full schema", () => {
			const code = generateRepositories(fullSchema);

			// Should have all node repos
			expect(code).toContain("FalkorMemoryRepository");
			expect(code).toContain("FalkorSessionRepository");
			expect(code).toContain("FalkorEntityRepository");

			// Should have section dividers
			expect(code).toContain("// Node Property Types");
			expect(code).toContain("// Repository Classes");
			expect(code).toContain("// Repository Factory");

			// Check overall structure
			expect(code.split("class Falkor").length).toBe(4); // 3 repos + 1 for initial split
		});
	});
});

describe("edge cases", () => {
	test("handles node without optional fields", () => {
		const SimpleNode = node({
			name: field.string(),
			value: field.int(),
		});

		const schema = defineSchema({
			nodes: { Simple: SimpleNode },
			edges: {},
		});

		const code = generateRepositories(schema);
		expect(code).toContain("FalkorSimpleRepository");
		expect(code).toContain("async create(input: CreateSimpleInput)");
	});

	test("handles node with all optional fields", () => {
		const OptionalNode = node({
			name: field.string().optional(),
			value: field.int().optional(),
		});

		const schema = defineSchema({
			nodes: { Optional: OptionalNode },
			edges: {},
		});

		const code = generateRepositories(schema);
		expect(code).toContain("FalkorOptionalRepository");
	});

	test("handles array fields", () => {
		const ArrayNode = node({
			items: field.array(field.string()),
			numbers: field.array(field.int()),
		});

		const schema = defineSchema({
			nodes: { ArrayTest: ArrayNode },
			edges: {},
		});

		const code = generateRepositories(schema);
		expect(code).toContain("items: string[];");
		expect(code).toContain("numbers: number[];");
	});

	test("handles vector fields", () => {
		const VectorNode = node({
			embedding: field.vector(1536),
		});

		const schema = defineSchema({
			nodes: { VectorTest: VectorNode },
			edges: {},
		});

		const code = generateRepositories(schema);
		expect(code).toContain("embedding: number[];");
	});
});
