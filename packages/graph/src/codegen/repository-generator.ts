/**
 * Repository Generator for Schema DSL
 *
 * Generates FalkorDB repository implementations for each node type defined in the schema.
 * The generated repositories extend FalkorBaseRepository and provide typed CRUD operations,
 * temporal queries, and relationship traversal methods.
 *
 * @example
 * ```typescript
 * import { generateRepositories } from './repository-generator';
 * import { engramSchema } from '../schema';
 *
 * const code = generateRepositories(engramSchema);
 * await Bun.write('src/generated/repositories.ts', code);
 * ```
 */

import type { EdgeDefinition } from "../schema/edge";
import type { NodeDefinition } from "../schema/node";
import type { Schema } from "../schema/schema";
import type { Field } from "../schema/types";

// =============================================================================
// Generator Configuration
// =============================================================================

/**
 * Configuration options for repository generation.
 */
export interface RepositoryGeneratorConfig {
	/**
	 * Whether to include JSDoc comments in generated code.
	 * @default true
	 */
	includeComments?: boolean;

	/**
	 * Whether to generate create operations.
	 * @default true
	 */
	generateCreate?: boolean;

	/**
	 * Whether to generate update operations with temporal versioning.
	 * @default true
	 */
	generateUpdate?: boolean;

	/**
	 * Whether to generate soft delete (expire) operations.
	 * @default true
	 */
	generateDelete?: boolean;

	/**
	 * Whether to generate temporal query methods (findByIdAt, asOf).
	 * @default true
	 */
	generateTemporalQueries?: boolean;

	/**
	 * Whether to generate field-specific finder methods (findByType, findByProject, etc.).
	 * @default true
	 */
	generateFieldFinders?: boolean;

	/**
	 * Whether to generate relationship traversal methods based on edges.
	 * @default true
	 */
	generateRelationshipMethods?: boolean;

	/**
	 * Header comment for the generated file.
	 * Set to false to disable header.
	 * @default true (generates standard AUTO-GENERATED header)
	 */
	includeHeader?: boolean | string;
}

const DEFAULT_CONFIG: Required<RepositoryGeneratorConfig> = {
	includeComments: true,
	generateCreate: true,
	generateUpdate: true,
	generateDelete: true,
	generateTemporalQueries: true,
	generateFieldFinders: true,
	generateRelationshipMethods: true,
	includeHeader: true,
};

// =============================================================================
// Type Mapping Utilities
// =============================================================================

/**
 * Get the full TypeScript type for a field.
 */
function getFieldTsType(field: Field): string {
	const kind = field.kind;
	const config = field.config;

	switch (kind) {
		case "string":
			return "string";
		case "int":
		case "float":
		case "timestamp":
			return "number";
		case "boolean":
			return "boolean";
		case "vector":
			return "number[]";
		case "array": {
			const arrayConfig = config as { inner?: Field };
			if (arrayConfig.inner) {
				return `${getFieldTsType(arrayConfig.inner)}[]`;
			}
			return "unknown[]";
		}
		case "enum": {
			const enumConfig = config as { values?: readonly string[] };
			if (enumConfig.values && enumConfig.values.length > 0) {
				return enumConfig.values.map((v) => `"${v}"`).join(" | ");
			}
			return "string";
		}
		default:
			return "unknown";
	}
}

/**
 * Convert camelCase to snake_case.
 */
function camelToSnake(str: string): string {
	return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

/**
 * Convert snake_case to camelCase.
 */
function snakeToCamel(str: string): string {
	return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Capitalize first letter.
 */
function capitalize(str: string): string {
	return str.charAt(0).toUpperCase() + str.slice(1);
}

// =============================================================================
// Code Generation Utilities
// =============================================================================

/**
 * Generate the standard auto-generated header.
 */
function generateHeader(): string {
	const timestamp = new Date().toISOString();
	return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by repository-generator.ts at ${timestamp}
// Run 'bun run codegen' to regenerate

`;
}

/**
 * Generate imports for the repository file.
 */
function generateImports(nodeNames: string[]): string {
	const lines: string[] = [];

	lines.push('import type { TenantContext } from "@engram/common/types";');
	lines.push('import type { FalkorNode, GraphClient } from "@engram/storage";');
	lines.push('import { TenantAwareFalkorClient } from "@engram/storage";');
	lines.push(
		'import { FalkorBaseRepository, type TimeTravelOptions } from "../repositories/falkor-base";',
	);
	lines.push("");

	// Import types for each node
	lines.push("// Generated type imports");
	for (const nodeName of nodeNames) {
		lines.push(
			`import type { ${nodeName}, Create${nodeName}Input, Update${nodeName}Input } from "./types";`,
		);
	}

	lines.push("");
	return lines.join("\n");
}

/**
 * Generate node props type for a node.
 */
function generateNodePropsType(
	nodeName: string,
	nodeDef: NodeDefinition<Record<string, Field>, boolean>,
): string {
	const lines: string[] = [];

	lines.push(`/**`);
	lines.push(` * Raw FalkorDB ${nodeName} node properties.`);
	lines.push(` */`);
	lines.push(`type ${nodeName}NodeProps = {`);
	lines.push(`\tid: string;`);

	for (const [fieldName, field] of Object.entries(nodeDef.fields)) {
		if (fieldName === "id") continue;
		const snakeFieldName = camelToSnake(fieldName);
		const tsType = getFieldTsType(field);
		const optional = field.config.optional ? "?" : "";
		lines.push(`\t${snakeFieldName}${optional}: ${tsType};`);
	}

	// Add bitemporal fields
	if (nodeDef.config.bitemporal) {
		lines.push(`\t// Bitemporal fields`);
		lines.push(`\tvt_start: number;`);
		lines.push(`\tvt_end: number;`);
		lines.push(`\ttt_start: number;`);
		lines.push(`\ttt_end: number;`);
	}

	lines.push(`\t[key: string]: unknown;`);
	lines.push(`};`);
	lines.push("");

	return lines.join("\n");
}

/**
 * Generate a repository class for a node type.
 */
function generateRepositoryClass(
	nodeName: string,
	nodeDef: NodeDefinition<Record<string, Field>, boolean>,
	_edges: Record<string, EdgeDefinition<Record<string, Field>>>,
	config: Required<RepositoryGeneratorConfig>,
): string {
	const lines: string[] = [];
	const label = nodeName;

	// Class declaration
	if (config.includeComments) {
		lines.push(`/**`);
		lines.push(` * FalkorDB repository implementation for ${nodeName} nodes.`);
		lines.push(` * Provides typed CRUD operations, temporal queries, and relationship handling.`);
		lines.push(` */`);
	}
	lines.push(`export class Falkor${nodeName}Repository extends FalkorBaseRepository {`);

	// findById method
	lines.push(`\t/**`);
	lines.push(`\t * Find a ${nodeName} by its ID (current version).`);
	lines.push(`\t */`);
	lines.push(`\tasync findById(id: string): Promise<${nodeName} | null> {`);
	lines.push(`\t\tconst results = await this.query<{ n: FalkorNode<${nodeName}NodeProps> }>(`);
	lines.push(`\t\t\t\`MATCH (n:${label} {id: $id}) WHERE n.tt_end = \${this.maxDate} RETURN n\`,`);
	lines.push(`\t\t\t{ id },`);
	lines.push(`\t\t);`);
	lines.push(`\t\tif (!results[0]?.n) return null;`);
	lines.push(`\t\treturn this.mapTo${nodeName}(results[0].n);`);
	lines.push(`\t}`);
	lines.push("");

	// findActive method
	lines.push(`\t/**`);
	lines.push(`\t * Find all active (current) ${nodeName} nodes.`);
	lines.push(`\t */`);
	lines.push(`\tasync findActive(): Promise<${nodeName}[]> {`);
	lines.push(`\t\tconst results = await this.query<{ n: FalkorNode<${nodeName}NodeProps> }>(`);
	lines.push(
		`\t\t\t\`MATCH (n:${label}) WHERE n.tt_end = \${this.maxDate} RETURN n ORDER BY n.vt_start DESC\`,`,
	);
	lines.push(`\t\t);`);
	lines.push(`\t\treturn results.map((r) => this.mapTo${nodeName}(r.n));`);
	lines.push(`\t}`);
	lines.push("");

	// Generate temporal queries
	if (config.generateTemporalQueries && nodeDef.config.bitemporal) {
		lines.push(`\t/**`);
		lines.push(`\t * Find a ${nodeName} as it existed at a specific point in time.`);
		lines.push(`\t */`);
		lines.push(
			`\tasync findByIdAt(id: string, options: TimeTravelOptions): Promise<${nodeName} | null> {`,
		);
		lines.push(`\t\tconst { vt, tt } = options;`);
		lines.push(`\t\tlet query = \`MATCH (n:${label} {id: $id})\`;`);
		lines.push(`\t\tconst params: Record<string, unknown> = { id };`);
		lines.push("");
		lines.push(`\t\tif (vt !== undefined) {`);
		lines.push(`\t\t\tquery += \` WHERE n.vt_start <= $vt AND n.vt_end > $vt\`;`);
		lines.push(`\t\t\tparams.vt = vt;`);
		lines.push(`\t\t}`);
		lines.push("");
		lines.push(`\t\tif (tt !== undefined) {`);
		lines.push(`\t\t\tconst ttVal = tt === "current" ? this.maxDate : tt;`);
		lines.push(`\t\t\tquery += vt !== undefined ? \` AND\` : \` WHERE\`;`);
		lines.push(`\t\t\tquery += \` n.tt_start <= $tt AND n.tt_end > $tt\`;`);
		lines.push(`\t\t\tparams.tt = ttVal;`);
		lines.push(`\t\t}`);
		lines.push("");
		lines.push(`\t\tquery += \` RETURN n\`;`);
		lines.push("");
		lines.push(
			`\t\tconst results = await this.query<{ n: FalkorNode<${nodeName}NodeProps> }>(query, params);`,
		);
		lines.push(`\t\tif (!results[0]?.n) return null;`);
		lines.push(`\t\treturn this.mapTo${nodeName}(results[0].n);`);
		lines.push(`\t}`);
		lines.push("");
	}

	// Generate field-specific finders for enum and string fields
	if (config.generateFieldFinders) {
		for (const [fieldName, field] of Object.entries(nodeDef.fields)) {
			if (fieldName === "id") continue;

			// Generate finder for enum fields
			if (field.kind === "enum") {
				const enumConfig = field.config as { values?: readonly string[] };
				if (enumConfig.values) {
					const methodName = `findBy${capitalize(snakeToCamel(fieldName))}`;
					const enumType = enumConfig.values.map((v) => `"${v}"`).join(" | ");
					const snakeField = camelToSnake(fieldName);

					lines.push(`\t/**`);
					lines.push(`\t * Find ${nodeName} nodes by ${fieldName}.`);
					lines.push(`\t */`);
					lines.push(`\tasync ${methodName}(value: ${enumType}): Promise<${nodeName}[]> {`);
					lines.push(
						`\t\tconst results = await this.query<{ n: FalkorNode<${nodeName}NodeProps> }>(`,
					);
					lines.push(
						`\t\t\t\`MATCH (n:${label} {${snakeField}: $value}) WHERE n.tt_end = \${this.maxDate} RETURN n ORDER BY n.vt_start DESC\`,`,
					);
					lines.push(`\t\t\t{ value },`);
					lines.push(`\t\t);`);
					lines.push(`\t\treturn results.map((r) => this.mapTo${nodeName}(r.n));`);
					lines.push(`\t}`);
					lines.push("");
				}
			}

			// Generate finder for string fields that look like foreign keys
			if (field.kind === "string" && (fieldName.endsWith("Id") || fieldName.endsWith("_id"))) {
				const methodName = `findBy${capitalize(snakeToCamel(fieldName))}`;
				const snakeField = camelToSnake(fieldName);

				lines.push(`\t/**`);
				lines.push(`\t * Find ${nodeName} nodes by ${fieldName}.`);
				lines.push(`\t */`);
				lines.push(`\tasync ${methodName}(value: string): Promise<${nodeName}[]> {`);
				lines.push(
					`\t\tconst results = await this.query<{ n: FalkorNode<${nodeName}NodeProps> }>(`,
				);
				lines.push(
					`\t\t\t\`MATCH (n:${label} {${snakeField}: $value}) WHERE n.tt_end = \${this.maxDate} RETURN n ORDER BY n.vt_start DESC\`,`,
				);
				lines.push(`\t\t\t{ value },`);
				lines.push(`\t\t);`);
				lines.push(`\t\treturn results.map((r) => this.mapTo${nodeName}(r.n));`);
				lines.push(`\t}`);
				lines.push("");
			}
		}
	}

	// Generate create method
	if (config.generateCreate) {
		lines.push(`\t/**`);
		lines.push(`\t * Create a new ${nodeName} node.`);
		lines.push(`\t */`);
		lines.push(`\tasync create(input: Create${nodeName}Input): Promise<${nodeName}> {`);
		lines.push(`\t\tconst id = this.generateId();`);
		lines.push(`\t\tconst temporal = this.createBitemporal();`);
		lines.push("");
		lines.push(`\t\tconst nodeProps: Record<string, unknown> = {`);
		lines.push(`\t\t\tid,`);

		// Add required fields
		// Note: Generated types use snake_case (matching FalkorDB), so we access input.snake_case
		for (const [fieldName, field] of Object.entries(nodeDef.fields)) {
			if (fieldName === "id") continue;
			const snakeField = camelToSnake(fieldName);

			if (field.config.optional) {
				// Optional fields are handled separately
				continue;
			}

			// Handle default values
			if (field.config.defaultValue !== undefined) {
				const defaultVal =
					typeof field.config.defaultValue === "string"
						? `"${field.config.defaultValue}"`
						: JSON.stringify(field.config.defaultValue);
				lines.push(`\t\t\t${snakeField}: input.${snakeField} ?? ${defaultVal},`);
			} else if (field.kind === "array") {
				lines.push(`\t\t\t${snakeField}: input.${snakeField} ?? [],`);
			} else {
				lines.push(`\t\t\t${snakeField}: input.${snakeField},`);
			}
		}

		// Add bitemporal fields
		if (nodeDef.config.bitemporal) {
			lines.push(`\t\t\t// Bitemporal fields`);
			lines.push(`\t\t\tvt_start: temporal.vt_start,`);
			lines.push(`\t\t\tvt_end: temporal.vt_end,`);
			lines.push(`\t\t\ttt_start: temporal.tt_start,`);
			lines.push(`\t\t\ttt_end: temporal.tt_end,`);
		}

		lines.push(`\t\t};`);
		lines.push("");

		// Handle optional fields
		// Note: Generated types use snake_case (matching FalkorDB)
		for (const [fieldName, field] of Object.entries(nodeDef.fields)) {
			if (fieldName === "id") continue;
			if (!field.config.optional) continue;

			const snakeField = camelToSnake(fieldName);
			lines.push(
				`\t\tif (input.${snakeField} !== undefined) nodeProps.${snakeField} = input.${snakeField};`,
			);
		}

		lines.push("");
		lines.push(`\t\tconst propsString = this.buildPropertyString(nodeProps);`);
		lines.push(`\t\tconst results = await this.query<{ n: FalkorNode<${nodeName}NodeProps> }>(`);
		lines.push(`\t\t\t\`CREATE (n:${label} {\${propsString}}) RETURN n\`,`);
		lines.push(`\t\t\tnodeProps,`);
		lines.push(`\t\t);`);
		lines.push("");
		lines.push(`\t\treturn this.mapTo${nodeName}(results[0].n);`);
		lines.push(`\t}`);
		lines.push("");
	}

	// Generate update method
	if (config.generateUpdate && nodeDef.config.bitemporal) {
		lines.push(`\t/**`);
		lines.push(`\t * Update a ${nodeName} node with temporal versioning.`);
		lines.push(`\t * Creates a new version and expires the old one.`);
		lines.push(`\t */`);
		lines.push(
			`\tasync update(id: string, updates: Update${nodeName}Input): Promise<${nodeName}> {`,
		);
		lines.push(`\t\tconst current = await this.findById(id);`);
		lines.push(`\t\tif (!current) {`);
		lines.push(`\t\t\tthrow new Error(\`${nodeName} not found: \${id}\`);`);
		lines.push(`\t\t}`);
		lines.push("");
		lines.push(`\t\tconst now = Date.now();`);
		lines.push("");
		lines.push(`\t\t// Expire current version`);
		lines.push(`\t\tawait this.query(`);
		lines.push(
			`\t\t\t\`MATCH (n:${label} {id: $id}) WHERE n.tt_end = \${this.maxDate} SET n.tt_end = $now\`,`,
		);
		lines.push(`\t\t\t{ id, now },`);
		lines.push(`\t\t);`);
		lines.push("");
		lines.push(`\t\t// Create new version with updates`);
		lines.push(`\t\tconst mergedInput = { ...current, ...updates } as Create${nodeName}Input;`);
		lines.push(`\t\treturn this.create(mergedInput);`);
		lines.push(`\t}`);
		lines.push("");
	}

	// Generate delete (expire) method
	if (config.generateDelete && nodeDef.config.bitemporal) {
		lines.push(`\t/**`);
		lines.push(`\t * Soft delete a ${nodeName} node by expiring it.`);
		lines.push(`\t */`);
		lines.push(`\tasync delete(id: string): Promise<boolean> {`);
		lines.push(`\t\tconst now = Date.now();`);
		lines.push(`\t\tconst results = await this.query<{ count: number }>(`);
		lines.push(
			`\t\t\t\`MATCH (n:${label} {id: $id}) WHERE n.tt_end = \${this.maxDate} SET n.tt_end = $now, n.vt_end = $now RETURN count(n) as count\`,`,
		);
		lines.push(`\t\t\t{ id, now },`);
		lines.push(`\t\t);`);
		lines.push(`\t\treturn (results[0]?.count ?? 0) > 0;`);
		lines.push(`\t}`);
		lines.push("");
	}

	// Generate mapping method
	// Note: Generated types use snake_case (matching FalkorDB), so we map directly
	lines.push(`\t/**`);
	lines.push(`\t * Map FalkorDB node properties to ${nodeName} domain object.`);
	lines.push(`\t */`);
	lines.push(`\tprivate mapTo${nodeName}(node: FalkorNode<${nodeName}NodeProps>): ${nodeName} {`);
	lines.push(`\t\tconst props = node.properties;`);
	lines.push(`\t\treturn {`);
	lines.push(`\t\t\tid: props.id,`);

	for (const [fieldName, _field] of Object.entries(nodeDef.fields)) {
		if (fieldName === "id") continue;
		const snakeField = camelToSnake(fieldName);
		// Generated types use snake_case, so map directly
		lines.push(`\t\t\t${snakeField}: props.${snakeField},`);
	}

	if (nodeDef.config.bitemporal) {
		lines.push(`\t\t\t// Bitemporal fields`);
		lines.push(`\t\t\tvt_start: props.vt_start,`);
		lines.push(`\t\t\tvt_end: props.vt_end,`);
		lines.push(`\t\t\ttt_start: props.tt_start,`);
		lines.push(`\t\t\ttt_end: props.tt_end,`);
	}

	lines.push(`\t\t};`);
	lines.push(`\t}`);

	// Close class
	lines.push(`}`);
	lines.push("");

	return lines.join("\n");
}

// =============================================================================
// Main Generator
// =============================================================================

/**
 * Generate FalkorDB repositories from a complete schema definition.
 *
 * @param schema - The schema to generate repositories for
 * @param config - Generator configuration
 * @returns Generated TypeScript code as a string
 *
 * @example
 * ```typescript
 * import { generateRepositories } from './repository-generator';
 * import { engramSchema } from '../schema';
 *
 * const code = generateRepositories(engramSchema);
 * await Bun.write('src/generated/repositories.ts', code);
 * ```
 */
export function generateRepositories(
	schema: Schema<Record<string, NodeDefinition<any, any>>, Record<string, EdgeDefinition<any>>>,
	config: Partial<RepositoryGeneratorConfig> = {},
): string {
	const finalConfig = { ...DEFAULT_CONFIG, ...config };
	const lines: string[] = [];
	const nodeNames = Object.keys(schema.nodes);

	// Header
	if (finalConfig.includeHeader) {
		if (typeof finalConfig.includeHeader === "string") {
			lines.push(finalConfig.includeHeader);
		} else {
			lines.push(generateHeader());
		}
	}

	// Imports
	lines.push(generateImports(nodeNames));

	// Node props types
	lines.push("// =============================================================================");
	lines.push("// Node Property Types");
	lines.push("// =============================================================================");
	lines.push("");

	for (const [nodeName, nodeDef] of Object.entries(schema.nodes)) {
		lines.push(generateNodePropsType(nodeName, nodeDef));
	}

	// Repository classes
	lines.push("// =============================================================================");
	lines.push("// Repository Classes");
	lines.push("// =============================================================================");
	lines.push("");

	for (const [nodeName, nodeDef] of Object.entries(schema.nodes)) {
		lines.push(generateRepositoryClass(nodeName, nodeDef, schema.edges, finalConfig));
	}

	// Export factory function
	lines.push("// =============================================================================");
	lines.push("// Repository Factory");
	lines.push("// =============================================================================");
	lines.push("");
	lines.push("/**");
	lines.push(" * Create all repositories with the given client and optional tenant context.");
	lines.push(" */");
	lines.push("export function createRepositories(");
	lines.push("\tclient: GraphClient | TenantAwareFalkorClient,");
	lines.push("\ttenantContext?: TenantContext,");
	lines.push("): {");

	for (const nodeName of nodeNames) {
		lines.push(
			`\t${nodeName.charAt(0).toLowerCase() + nodeName.slice(1)}: Falkor${nodeName}Repository;`,
		);
	}

	lines.push("} {");
	lines.push("\treturn {");

	for (const nodeName of nodeNames) {
		const varName = nodeName.charAt(0).toLowerCase() + nodeName.slice(1);
		lines.push(`\t\t${varName}: new Falkor${nodeName}Repository(client, tenantContext),`);
	}

	lines.push("\t};");
	lines.push("}");
	lines.push("");

	return lines.join("\n");
}

/**
 * Generate repositories and write to a file.
 *
 * @param schema - The schema to generate repositories for
 * @param outputPath - Path to write the generated file
 * @param config - Generator configuration
 */
export async function generateRepositoriesToFile(
	schema: Schema<Record<string, NodeDefinition<any, any>>, Record<string, EdgeDefinition<any>>>,
	outputPath: string,
	config: Partial<RepositoryGeneratorConfig> = {},
): Promise<void> {
	const code = generateRepositories(schema, config);
	await Bun.write(outputPath, code);
}
