import { describe, expect, test } from "bun:test";
import { mcp } from "../schema/mcp";
import { generateMcpTools } from "./mcp-generator";

// Test tool definitions
const memoryTypes = ["decision", "context", "insight", "preference", "fact"] as const;

const testTools = mcp.defineTools({
	remember: mcp.tool({
		title: "Remember",
		description: "Store a memory for future recall",
		input: {
			content: mcp.param.string("The memory content to store").min(1),
			type: mcp.param.enum(memoryTypes, "Classification of the memory").optional(),
			tags: mcp.param.array(mcp.param.string(), "Keywords for filtering").optional(),
		},
		output: {
			id: mcp.param.string("Created memory ID"),
			stored: mcp.param.boolean("Success indicator"),
		},
	}),
	recall: mcp.tool({
		title: "Recall",
		description: "Search past memories",
		input: {
			query: mcp.param.string("Search query"),
			limit: mcp.param.int("Maximum results").min(1).max(100).default(10),
			filters: mcp.param
				.object(
					{
						type: mcp.param.enum(memoryTypes).optional(),
						project: mcp.param.string().optional(),
					},
					"Optional filters",
				)
				.optional(),
		},
		output: {
			memories: mcp.param.array(
				mcp.param.object({
					id: mcp.param.string(),
					content: mcp.param.string(),
					score: mcp.param.float(),
				}),
			),
			count: mcp.param.int(),
		},
	}),
	query: mcp.tool({
		title: "Query",
		description: "Execute a read-only Cypher query",
		input: {
			cypher: mcp.param.string("The Cypher query to execute"),
		},
		annotations: {
			readOnlyHint: true,
		},
	}),
});

describe("generateMcpTools", () => {
	describe("header generation", () => {
		test("includes auto-generated header by default", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("// AUTO-GENERATED FILE - DO NOT EDIT");
			expect(code).toContain("// Generated by mcp-generator.ts");
		});

		test("allows custom header", () => {
			const code = generateMcpTools(testTools, {
				includeHeader: "// Custom header\n",
			});
			expect(code).toContain("// Custom header");
			expect(code).not.toContain("// AUTO-GENERATED");
		});

		test("can disable header", () => {
			const code = generateMcpTools(testTools, {
				includeHeader: false,
			});
			expect(code).not.toContain("// AUTO-GENERATED");
		});
	});

	describe("imports", () => {
		test("includes McpServer import", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("import type { McpServer }");
		});

		test("includes Zod import", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('import { z } from "zod"');
		});
	});

	describe("Zod schema generation", () => {
		test("generates input schemas for all tools", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export const rememberInputSchema = z.object({");
			expect(code).toContain("export const recallInputSchema = z.object({");
			expect(code).toContain("export const queryInputSchema = z.object({");
		});

		test("generates output schemas when present", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export const rememberOutputSchema = z.object({");
			expect(code).toContain("export const recallOutputSchema = z.object({");
			// query has no output
			expect(code).not.toContain("queryOutputSchema");
		});

		test("generates type exports", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export type RememberInput = z.infer<typeof rememberInputSchema>;");
			expect(code).toContain("export type RememberOutput = z.infer<typeof rememberOutputSchema>;");
			expect(code).toContain("export type RecallInput = z.infer<typeof recallInputSchema>;");
		});

		test("handles string params with constraints", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("z.string()");
			expect(code).toContain(".min(1)");
		});

		test("handles int params with constraints", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("z.number().int()");
			expect(code).toContain(".min(1)");
			expect(code).toContain(".max(100)");
		});

		test("handles enum params", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('z.enum(["decision", "context", "insight", "preference", "fact"])');
		});

		test("handles array params", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("z.array(z.string())");
		});

		test("handles object params", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("z.object({");
		});

		test("handles optional modifier", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain(".optional()");
		});

		test("handles default modifier", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain(".default(10)");
		});

		test("handles describe modifier", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain(".describe('The memory content to store')");
		});

		test("can disable Zod schema generation", () => {
			const code = generateMcpTools(testTools, { generateZodSchemas: false });
			// Should not have the standalone schema exports
			expect(code).not.toContain("export const rememberInputSchema = z.object({");
			expect(code).not.toContain("export type RememberInput =");
		});
	});

	describe("JSON Schema generation", () => {
		test("generates JSON Schema for all tools", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export const rememberInputJsonSchema =");
			expect(code).toContain("export const recallInputJsonSchema =");
			expect(code).toContain("export const queryInputJsonSchema =");
		});

		test("JSON Schema has correct structure", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('"type": "object"');
			expect(code).toContain('"properties"');
		});

		test("JSON Schema includes required array for non-optional params", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('"required"');
		});

		test("JSON Schema includes descriptions", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('"description": "The memory content to store"');
		});

		test("JSON Schema handles enum types", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('"enum"');
		});

		test("JSON Schema handles integer type", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('"type": "integer"');
		});

		test("JSON Schema handles array type", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('"type": "array"');
			expect(code).toContain('"items"');
		});

		test("can disable JSON Schema generation", () => {
			const code = generateMcpTools(testTools, { generateJsonSchema: false });
			expect(code).not.toContain("rememberInputJsonSchema");
		});
	});

	describe("registration function generation", () => {
		test("generates registration functions for all tools", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export function registerRememberTool(");
			expect(code).toContain("export function registerRecallTool(");
			expect(code).toContain("export function registerQueryTool(");
		});

		test("functions accept McpServer parameter", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("server: McpServer,");
		});

		test("functions accept typed handler parameter", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("handler: (input: z.infer<typeof rememberInputSchema>)");
		});

		test("functions call server.registerTool", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("server.registerTool(");
			expect(code).toContain('"remember"');
		});

		test("registration includes title", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('title: "Remember"');
		});

		test("registration includes description", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain('description: "Store a memory for future recall"');
		});

		test("registration includes inputSchema", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("inputSchema:");
		});

		test("registration includes outputSchema when present", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("outputSchema:");
		});

		test("registration includes annotations when present", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("annotations:");
			expect(code).toContain("readOnlyHint");
		});

		test("handler validates input with Zod", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("rememberInputSchema.parse(inputs)");
		});

		test("handler returns structured content", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("structuredContent: result");
		});

		test("can disable registration function generation", () => {
			const code = generateMcpTools(testTools, { generateRegistrationFunctions: false });
			expect(code).not.toContain("registerRememberTool");
		});
	});

	describe("tool names export", () => {
		test("exports toolNames array", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export const toolNames = [");
			expect(code).toContain('"remember"');
			expect(code).toContain('"recall"');
			expect(code).toContain('"query"');
			expect(code).toContain("] as const;");
		});

		test("exports ToolName type", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("export type ToolName = (typeof toolNames)[number];");
		});
	});

	describe("comments generation", () => {
		test("includes JSDoc comments by default", () => {
			const code = generateMcpTools(testTools);
			expect(code).toContain("/**");
			expect(code).toContain(" * Input schema for the remember tool.");
		});

		test("can disable comments", () => {
			const code = generateMcpTools(testTools, { includeComments: false });
			expect(code).not.toContain("* Input schema for");
		});
	});
});

describe("edge cases", () => {
	test("handles tool with no output", () => {
		const tools = mcp.defineTools({
			noOutput: mcp.tool({
				description: "Tool without output",
				input: {
					value: mcp.param.string(),
				},
			}),
		});

		const code = generateMcpTools(tools);
		expect(code).toContain("noOutputInputSchema");
		expect(code).not.toContain("noOutputOutputSchema");
		expect(code).toContain('content: [{ type: "text", text: "OK" }]');
	});

	test("handles tool with boolean params", () => {
		const tools = mcp.defineTools({
			boolTool: mcp.tool({
				description: "Tool with boolean",
				input: {
					enabled: mcp.param.boolean("Enable feature"),
				},
			}),
		});

		const code = generateMcpTools(tools);
		expect(code).toContain("z.boolean()");
		expect(code).toContain('"type": "boolean"');
	});

	test("handles tool with float params", () => {
		const tools = mcp.defineTools({
			floatTool: mcp.tool({
				description: "Tool with float",
				input: {
					score: mcp.param.float("Score value").min(0).max(1),
				},
			}),
		});

		const code = generateMcpTools(tools);
		expect(code).toContain("z.number()");
		expect(code).toContain('"type": "number"');
		expect(code).toContain('"minimum": 0');
		expect(code).toContain('"maximum": 1');
	});

	test("handles nested objects", () => {
		const tools = mcp.defineTools({
			nestedTool: mcp.tool({
				description: "Tool with nested object",
				input: {
					config: mcp.param.object({
						nested: mcp.param.object({
							value: mcp.param.string(),
						}),
					}),
				},
			}),
		});

		const code = generateMcpTools(tools);
		expect(code).toContain("z.object({");
		expect(code.match(/z\.object\(/g)?.length).toBeGreaterThan(2);
	});

	test("handles array of objects", () => {
		const tools = mcp.defineTools({
			arrayObjTool: mcp.tool({
				description: "Tool with array of objects",
				input: {
					items: mcp.param.array(
						mcp.param.object({
							id: mcp.param.string(),
							value: mcp.param.int(),
						}),
					),
				},
			}),
		});

		const code = generateMcpTools(tools);
		expect(code).toContain("z.array(z.object({");
	});

	test("escapes special characters in descriptions", () => {
		const tools = mcp.defineTools({
			specialTool: mcp.tool({
				description: 'Tool with "quotes" and \\n newlines',
				input: {
					value: mcp.param.string("Description with 'quotes'"),
				},
			}),
		});

		const code = generateMcpTools(tools);
		// Should escape quotes in description
		expect(code).toContain('\\"quotes\\"');
	});
});
